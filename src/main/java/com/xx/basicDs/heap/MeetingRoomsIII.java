package com.xx.basicDs.heap;

import java.util.Arrays;
import java.util.PriorityQueue;

/**
 * 会议室III
 * LeetCode 2402. Hard
 * <p>
 * 给你一个整数 n ，共有编号从 0 到 n - 1 的 n 个会议室。
 * 给你一个二维整数数组 meetings ，其中 meetings[i] = [starti, endi] 表示一场会议将会在 半闭 时间区间 [starti, endi) 举办。
 * 所有 starti 的值 互不相同 。
 * <p>
 * 会议将会按以下方式分配给会议室：
 * 每场会议都会在未占用且编号 最小 的会议室举办。
 * 如果没有可用的会议室，会议将会延期，直到存在空闲的会议室。延期会议的持续时间和原会议持续时间 相同 。
 * 当会议室处于未占用状态时，将会优先提供给原 开始 时间更早的会议。
 * 返回举办最多次会议的房间 编号 。如果存在多个房间满足此条件，则返回编号 最小 的房间。
 * <p>
 * 半闭区间 [a, b) 是 a 和 b 之间的区间，包括 a 但 不包括 b 。
 * <p>
 * 示例 1：
 * 输入：n = 2, meetings = [[0,10],[1,5],[2,7],[3,4]]
 * 输出：0
 * 解释：
 * - 在时间 0 ，两个会议室都未占用，第一场会议在会议室 0 举办。
 * - 在时间 1 ，只有会议室 1 未占用，第二场会议在会议室 1 举办。
 * - 在时间 2 ，两个会议室都被占用，第三场会议延期举办。
 * - 在时间 3 ，两个会议室都被占用，第四场会议延期举办。
 * - 在时间 5 ，会议室 1 的会议结束。第三场会议在会议室 1 举办，时间周期为 [5,10) 。
 * - 在时间 10 ，两个会议室的会议都结束。第四场会议在会议室 0 举办，时间周期为 [10,11) 。
 * 会议室 0 和会议室 1 都举办了 2 场会议，所以返回 0 。
 * <p>
 * 示例 2：
 * 输入：n = 3, meetings = [[1,20],[2,10],[3,5],[4,9],[6,8]]
 * 输出：1
 * 解释：
 * - 在时间 1 ，所有三个会议室都未占用，第一场会议在会议室 0 举办。
 * - 在时间 2 ，会议室 1 和 2 未占用，第二场会议在会议室 1 举办。
 * - 在时间 3 ，只有会议室 2 未占用，第三场会议在会议室 2 举办。
 * - 在时间 4 ，所有三个会议室都被占用，第四场会议延期举办。
 * - 在时间 5 ，会议室 2 的会议结束。第四场会议在会议室 2 举办，时间周期为 [5,10) 。
 * - 在时间 6 ，所有三个会议室都被占用，第五场会议延期举办。
 * - 在时间 10 ，会议室 1 和 2 的会议结束。第五场会议在会议室 1 举办，时间周期为 [10,12) 。
 * 会议室 1 和会议室 2 都举办了 2 场会议，所以返回 1 。
 * <p>
 * 提示：
 * 1 <= n <= 100
 * 1 <= meetings.length <= 105
 * meetings[i].length == 2
 * 0 <= starti < endi <= 5 * 105
 * starti 的所有值 互不相同
 * <p>
 * 反复提交多次的问题：
 * 第一次提交：题目没读清楚，会议不是一开始就非要把N个全占满的，开始时间需要比较。所以size != n的逻辑需要重写。
 * 第二次提交：不够细心，人家都说了是开区间，我还是用的<而不是<=.
 * 第三次提交：count求最大值的逻辑重构，提了一个全局变量，这个在写之前就应该考虑清楚。
 * 第四次提交：数据整理了半天，才反应过来不能用int，count得用long型，应该在看到那些数据的一瞬间就反应过来才对。
 * <p>
 * 注意的事项：读题读清楚了再开始；条件限制一定要想明白。
 * <p>
 * Tag：堆
 */
public class MeetingRoomsIII {

    /**
     * 方法一：优先队列（小根堆）
     * 我们定义两个优先队列，分别表示空闲会议室、使用中的会议室。
     * 其中：空闲会议室 idle 依据下标排序；而使用中的会议室 busy 依据结束时间、下标排序。
     * <p>
     * 先对会议按照开始时间排序，然后遍历会议，对于每个会议：
     * <p>
     * 若有使用中的会议室的结束时间小于当前等于会议的开始时间，将其加入到空闲会议室队列 idle 中；
     * 若当前有空闲会议室，那么在空闲队列 idle 中取出权重最小的会议室，将其加入使用中的队列 busy 中；
     * 若当前没有空闲会议室，那么在使用队列 busy 中找出最早结束时间且下标最小的会议室，重新加入使用中的队列 busy 中。
     *
     */
    public int mostBooked(int n, int[][] meetings) {
        Arrays.sort(meetings, (a, b) -> a[0] - b[0]);
        PriorityQueue<int[]> busy
                = new PriorityQueue<>((a, b) -> a[0] == b[0] ? a[1] - b[1] : a[0] - b[0]);
        PriorityQueue<Integer> idle = new PriorityQueue<>();
        // 刚开始全是空闲
        for (int i = 0; i < n; ++i) {
            idle.offer(i);
        }
        // 会议室的使用次数
        int[] cnt = new int[n];
        for (int[] meeting : meetings) {
            int startTime = meeting[0], endTime = meeting[1];
            // busy根据使用时间排序的
            while (!busy.isEmpty() && busy.peek()[0] <= startTime) {
                // 序号添加
                idle.offer(busy.poll()[1]);
            }
            int i = 0;
            if (!idle.isEmpty()) {
                i = idle.poll();
                busy.offer(new int[]{endTime, i});
            } else {
                // 没有空闲的，说明需要延期
                int[] x = busy.poll();
                i = x[1];
                busy.offer(new int[]{x[0] + endTime - startTime, i});
            }
            ++cnt[i];
        }
        int ans = 0;
        for (int i = 0; i < n; ++i) {
            if (cnt[ans] < cnt[i]) {
                ans = i;
            }
        }
        return ans;
    }

}
